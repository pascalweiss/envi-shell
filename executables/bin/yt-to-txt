#!/usr/bin/env bash
set -euo pipefail

# ---------------------------------------------------------------------------
# Colors & logging
# ---------------------------------------------------------------------------
_CLR_GREEN='\033[0;32m'
_CLR_YELLOW='\033[0;33m'
_CLR_BLUE='\033[1;34m'
_CLR_RED='\033[0;31m'
_CLR_DIM='\033[2m'
_CLR_RESET='\033[0m'

log()      { printf "${_CLR_BLUE}[yt-to-txt]${_CLR_RESET} %s\n" "$*"; }
log_step() { local l="$1"; shift; printf "${_CLR_YELLOW}  [%s]${_CLR_RESET} %s\n" "$l" "$*"; }
log_done() { printf "${_CLR_GREEN}  [done]${_CLR_RESET} %s\n" "$*"; }
log_err()  { printf "${_CLR_RED}  [error]${_CLR_RESET} %s\n" "$*" >&2; }

# Worker-prefixed variants (worker_id=0 means no prefix)
wlog()      { local w="$1"; shift; if [[ "$w" -gt 0 ]]; then printf "${_CLR_DIM}[worker %d]${_CLR_RESET} %s\n" "$w" "$*"; else log "$@"; fi; }
wlog_step() { local w="$1"; shift; local l="$1"; shift; if [[ "$w" -gt 0 ]]; then printf "${_CLR_DIM}[worker %d]${_CLR_RESET}${_CLR_YELLOW}  [%s]${_CLR_RESET} %s\n" "$w" "$l" "$*"; else log_step "$l" "$@"; fi; }
wlog_done() { local w="$1"; shift; if [[ "$w" -gt 0 ]]; then printf "${_CLR_DIM}[worker %d]${_CLR_RESET}${_CLR_GREEN}  [done]${_CLR_RESET} %s\n" "$w" "$*"; else log_done "$@"; fi; }
wlog_err()  { local w="$1"; shift; if [[ "$w" -gt 0 ]]; then printf "${_CLR_DIM}[worker %d]${_CLR_RESET}${_CLR_RED}  [error]${_CLR_RESET} %s\n" "$w" "$*" >&2; else log_err "$@"; fi; }

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
sanitize() {
  local input="$1"
  printf '%s' "$input" \
    | LC_ALL=C tr '[:upper:]' '[:lower:]' \
    | tr -c 'a-z0-9' '_' \
    | sed -E 's/_+/_/g; s/^_+//; s/_+$//'
}

# ---------------------------------------------------------------------------
# Help
# ---------------------------------------------------------------------------
show_help() {
  cat <<'EOF'
Usage: yt-to-txt <video_url> [options]
       yt-to-txt --url <video_url> [options]
       yt-to-txt --channel <channel_url> [options]

Downloads audio with yt-dlp, transcribes with whisper-cpp (Metal GPU), and writes:
  - audio file (default mp3)
  - transcript (default txt)
  - info.txt with basic video metadata
All outputs go into a folder named after the video title (sanitized).

Options:
  -u, --url <url>             Video URL (can also be passed as first argument)
  -m, --model <name|path>     Whisper model name or path to GGML .bin file
                              Names: tiny, base, small, medium, large-v3, large-v3-turbo, ...
                              (default: large-v3-turbo; auto-downloaded to ~/.cache/whisper-cpp/)
      --no-gpu                Disable GPU acceleration (Metal is used by default on Apple Silicon)
  -l, --language <code>       Language code, e.g. en, de, auto (default: auto)
  -f, --output-format <fmt>   Transcript format: txt|vtt|srt|csv|json|all (default: txt)
  -a, --audio-format <fmt>    Audio format for download (default: mp3)
  -k, --keep-audio            Keep the downloaded audio file (default: delete after transcription)
  -o, --output-dir <dir>      Base output directory (default: $YT_TRANSCRIBE_OUTPUT_DIR or current dir)
  -h, --help                  Show this help and exit

Channel Mode:
  -c, --channel <url>         Transcribe all videos from a YouTube channel
      --min-seconds <N>       Skip videos shorter than N seconds (default: 60)
      --amount <N>            Transcribe at most N new videos (default: all)
      --workers <N>           Number of parallel workers (default: 1)

Notes:
  - Uses whisper-cpp with Metal GPU acceleration on Apple Silicon by default.
  - Models are auto-downloaded from Hugging Face on first use.
  - Title and filenames are sanitized to ASCII-safe characters.
  - In channel mode, already-transcribed videos (existing output folder) are skipped.
  - --amount counts only new transcriptions (skipped videos don't count).
EOF
}

# ---------------------------------------------------------------------------
# Argument parsing
# ---------------------------------------------------------------------------
url=""
channel_url=""
model="large-v3-turbo"
no_gpu="0"
language="auto"
output_format="txt"
audio_format="mp3"
keep_audio="0"
output_dir="${YT_TRANSCRIBE_OUTPUT_DIR:-.}"
model_dir="${WHISPER_CPP_MODEL_DIR:-${HOME}/.cache/whisper-cpp}"
min_seconds="60"
amount="0"
workers="1"

# Expand leading ~ so tools like ffmpeg/whisper can resolve the path.
case "$output_dir" in
  "~"|"~/"*)
    output_dir="${HOME}${output_dir#\~}"
    ;;
esac

while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--url)
      url="${2:-}"
      shift 2
      ;;
    -c|--channel)
      channel_url="${2:-}"
      shift 2
      ;;
    -m|--model)
      model="${2:-}"
      shift 2
      ;;
    --no-gpu)
      no_gpu="1"
      shift
      ;;
    -l|--language)
      language="${2:-}"
      shift 2
      ;;
    -f|--output-format)
      output_format="${2:-}"
      shift 2
      ;;
    -a|--audio-format)
      audio_format="${2:-}"
      shift 2
      ;;
    -k|--keep-audio)
      keep_audio="1"
      shift
      ;;
    -o|--output-dir)
      output_dir="${2:-}"
      shift 2
      ;;
    --min-seconds)
      min_seconds="${2:-}"
      shift 2
      ;;
    --amount)
      amount="${2:-}"
      shift 2
      ;;
    --workers)
      workers="${2:-}"
      shift 2
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      if [[ "$1" != -* && -z "$url" ]]; then
        url="$1"
        shift
      else
        echo "Unknown argument: $1" >&2
        echo "Run with --help for usage." >&2
        exit 1
      fi
      ;;
  esac
done

# Validation
if [[ -n "$channel_url" && -n "$url" ]]; then
  echo "Cannot use --channel and --url together." >&2
  exit 1
fi
if [[ -z "$channel_url" && -z "$url" ]]; then
  echo "Missing URL. Provide a video URL or --channel <url>." >&2
  echo "Run with --help for usage." >&2
  exit 1
fi
if ! [[ "$min_seconds" =~ ^[0-9]+$ ]] || [[ "$min_seconds" -lt 0 ]]; then
  echo "--min-seconds must be a non-negative integer." >&2
  exit 1
fi
if ! [[ "$amount" =~ ^[0-9]+$ ]]; then
  echo "--amount must be a non-negative integer (0 = all)." >&2
  exit 1
fi
if ! [[ "$workers" =~ ^[1-9][0-9]*$ ]]; then
  echo "--workers must be a positive integer." >&2
  exit 1
fi

# Dependency check
for cmd in yt-dlp whisper-cli ffmpeg; do
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "Missing dependency: $cmd" >&2
    exit 1
  fi
done

# ---------------------------------------------------------------------------
# Model resolution: name -> GGML file path (auto-download if needed)
# ---------------------------------------------------------------------------
resolve_model() {
  local _model="$1"

  # If it's already a file path, use it directly
  if [[ -f "$_model" ]]; then
    printf '%s' "$_model"
    return 0
  fi

  # Resolve model name to ggml file
  local model_file="ggml-${_model}.bin"
  local model_path="${model_dir}/${model_file}"

  if [[ -f "$model_path" ]]; then
    printf '%s' "$model_path"
    return 0
  fi

  # Auto-download from Hugging Face
  local download_url="https://huggingface.co/ggerganov/whisper.cpp/resolve/main/${model_file}"
  log "Downloading model ${model_file}..."
  mkdir -p "$model_dir"
  if ! curl -fL --progress-bar -o "$model_path" "$download_url"; then
    rm -f "$model_path"
    log_err "Failed to download model from ${download_url}"
    log_err "Available models: tiny, base, small, medium, large-v3, large-v3-turbo"
    return 1
  fi
  log "Model saved to ${model_path}"

  printf '%s' "$model_path"
}

model_path="$(resolve_model "$model")"

# ---------------------------------------------------------------------------
# Core: transcribe a single video
# ---------------------------------------------------------------------------
transcribe_single_video() {
  local video_url="$1"
  local _output_dir="$2"
  local _model_path="$3"
  local _no_gpu="$4"
  local _language="$5"
  local _output_format="$6"
  local _audio_format="$7"
  local _keep_audio="$8"
  local _worker_id="${9:-0}"
  local _video_num="${10:-}"

  local _progress=""
  if [[ -n "$_video_num" ]]; then
    _progress="(${_video_num}) "
  fi

  # Fetch metadata in a single yt-dlp call
  local meta
  meta="$(yt-dlp --print "%(title)s" --print "%(id)s" --print "%(channel)s" "$video_url" 2>/dev/null)"
  local title video_id channel_name
  title="$(sed -n '1p' <<< "$meta")"
  video_id="$(sed -n '2p' <<< "$meta")"
  channel_name="$(sed -n '3p' <<< "$meta")"

  wlog "$_worker_id" "${_progress}Processing: \"${title}\" (${video_id})"

  local ch_dir
  ch_dir="$(sanitize "$channel_name")"
  if [[ -z "$ch_dir" ]]; then
    ch_dir="unknown_channel"
  fi

  local vid_dir
  vid_dir="$(sanitize "$title")"
  if [[ -z "$vid_dir" ]]; then
    vid_dir="$(sanitize "$video_id")"
  fi

  local target_dir="${_output_dir%/}/${ch_dir}/${vid_dir}"
  mkdir -p "$target_dir"

  local audio_basename="$vid_dir"
  local audio_path="${target_dir}/${audio_basename}.${_audio_format}"

  # Download audio
  wlog_step "$_worker_id" "download" "Downloading audio..."
  yt-dlp -x \
    --audio-format "$_audio_format" \
    --audio-quality 0 \
    --quiet --no-warnings \
    -o "${target_dir}/${audio_basename}.%(ext)s" \
    "$video_url"

  # Write initial info.yaml
  local info_path="${target_dir}/info.yaml"
  cat <<INFOEOF > "$info_path"
title: "${title//\"/\\\"}"
id: "${video_id}"
channel: "${channel_name//\"/\\\"}"
url: "${video_url}"
INFOEOF

  # Transcribe with whisper-cli
  local _model_name
  _model_name="$(basename "$_model_path" .bin)"
  wlog_step "$_worker_id" "transcribe" "Transcribing with ${_model_name} ($([ "$_no_gpu" = "1" ] && echo "cpu" || echo "gpu"))..."
  local whisper_log="${target_dir}/whisper.log"
  local output_file_base="${target_dir}/${audio_basename}"

  local whisper_args=(
    --model "$_model_path"
    --language "$_language"
    --no-prints
    --output-file "$output_file_base"
    --file "$audio_path"
  )

  # Output format flags
  case "$_output_format" in
    txt)  whisper_args+=(--output-txt) ;;
    vtt)  whisper_args+=(--output-vtt) ;;
    srt)  whisper_args+=(--output-srt) ;;
    csv)  whisper_args+=(--output-csv) ;;
    json) whisper_args+=(--output-json) ;;
    all)  whisper_args+=(--output-txt --output-vtt --output-srt --output-csv --output-json) ;;
    *)    whisper_args+=(--output-txt) ;;
  esac

  if [[ "$_no_gpu" = "1" ]]; then
    whisper_args+=(--no-gpu)
  fi

  local whisper_rc=0
  whisper-cli "${whisper_args[@]}" >"$whisper_log" 2>&1 || whisper_rc=$?

  # Finalize info.yaml
  local word_count="unknown"
  local transcript_path="${target_dir}/${audio_basename}.txt"
  if [[ -f "$transcript_path" ]]; then
    word_count="$(LC_ALL=C wc -w < "$transcript_path" | tr -d ' ')"
  fi

  if [[ $whisper_rc -eq 0 ]]; then
    local timestamp
    timestamp="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    cat <<INFOEOF > "$info_path"
title: "${title//\"/\\\"}"
id: "${video_id}"
channel: "${channel_name//\"/\\\"}"
url: "${video_url}"
word_count: ${word_count}
transcribed_at: "${timestamp}"
INFOEOF
    rm -f "$whisper_log"
  else
    cat <<INFOEOF > "$info_path"
title: "${title//\"/\\\"}"
id: "${video_id}"
channel: "${channel_name//\"/\\\"}"
url: "${video_url}"
word_count: ${word_count}
INFOEOF
    wlog_err "$_worker_id" "${_progress}Transcription failed (see ${whisper_log})"
  fi

  # Clean up audio
  if [[ "$_keep_audio" != "1" ]]; then
    rm -f "$audio_path"
  fi

  if [[ $whisper_rc -ne 0 ]]; then
    return 1
  fi

  wlog_done "$_worker_id" "${_progress}${target_dir}"
}

# ---------------------------------------------------------------------------
# Channel mode helpers
# ---------------------------------------------------------------------------
fetch_channel_video_ids() {
  local _channel_url="$1"
  local _min_seconds="$2"
  yt-dlp \
    --flat-playlist \
    --match-filter "duration>=${_min_seconds}" \
    --print id \
    "$_channel_url" 2>/dev/null
}

get_transcribed_ids() {
  local _base_dir="$1"
  if [[ -d "$_base_dir" ]]; then
    grep -rh '^id: ' "$_base_dir"/*/info.yaml "$_base_dir"/*/info.txt 2>/dev/null \
      | sed 's/^id: "//; s/"$//' \
      | sort -u
  fi
}

# ---------------------------------------------------------------------------
# Sequential runner (workers=1 or single-video batch)
# ---------------------------------------------------------------------------
run_sequential() {
  local total="$1"
  shift
  local video_ids=("$@")
  local succeeded=0
  local failed=0

  set +e
  local i
  for i in "${!video_ids[@]}"; do
    local vid="${video_ids[$i]}"
    local video_num="$(( i + 1 ))/${total}"

    (
      set -euo pipefail
      transcribe_single_video \
        "https://www.youtube.com/watch?v=${vid}" \
        "$output_dir" "$model_path" "$no_gpu" "$language" \
        "$output_format" "$audio_format" "$keep_audio" \
        "0" "$video_num"
    )
    if [[ $? -eq 0 ]]; then
      succeeded=$(( succeeded + 1 ))
    else
      failed=$(( failed + 1 ))
    fi
  done
  set -e

  log "Batch complete: ${succeeded} succeeded, ${failed} failed"
  if [[ $failed -gt 0 ]]; then
    return 1
  fi
  return 0
}

# ---------------------------------------------------------------------------
# Parallel worker pool (bash 3.2 compatible — no wait -n)
# ---------------------------------------------------------------------------
run_worker_pool() {
  local max_workers="$1"
  local total="$2"
  shift 2
  local video_ids=("$@")
  local vid_count=${#video_ids[@]}
  local next_idx=0
  local succeeded=0
  local failed=0

  # Parallel arrays: pids[i] <-> pid_workers[i], tracked with num_pids
  local num_pids=0

  set +e
  while [[ $next_idx -lt $vid_count || $num_pids -gt 0 ]]; do

    # Fill worker slots
    while [[ $num_pids -lt $max_workers && $next_idx -lt $vid_count ]]; do
      local vid="${video_ids[$next_idx]}"
      local worker_id=$(( (next_idx % max_workers) + 1 ))
      local video_num="$(( next_idx + 1 ))/${total}"

      (
        set -euo pipefail
        transcribe_single_video \
          "https://www.youtube.com/watch?v=${vid}" \
          "$output_dir" "$model_path" "$no_gpu" "$language" \
          "$output_format" "$audio_format" "$keep_audio" \
          "$worker_id" "$video_num"
      ) &

      pids[$num_pids]=$!
      pid_workers[$num_pids]="$worker_id"
      num_pids=$(( num_pids + 1 ))
      next_idx=$(( next_idx + 1 ))
    done

    # Poll for completed PIDs — rebuild arrays in place
    local new_count=0
    local i=0
    while [[ $i -lt $num_pids ]]; do
      if kill -0 "${pids[$i]}" 2>/dev/null; then
        pids[$new_count]="${pids[$i]}"
        pid_workers[$new_count]="${pid_workers[$i]}"
        new_count=$(( new_count + 1 ))
      else
        wait "${pids[$i]}"
        if [[ $? -eq 0 ]]; then
          succeeded=$(( succeeded + 1 ))
        else
          failed=$(( failed + 1 ))
        fi
      fi
      i=$(( i + 1 ))
    done
    num_pids=$new_count

    # Avoid busy-wait
    if [[ $num_pids -ge $max_workers ]]; then
      sleep 1
    fi
  done
  set -e

  log "Batch complete: ${succeeded} succeeded, ${failed} failed"
  if [[ $failed -gt 0 ]]; then
    return 1
  fi
  return 0
}

# ---------------------------------------------------------------------------
# Channel mode
# ---------------------------------------------------------------------------
channel_mode() {
  log "Fetching video list (min duration: ${min_seconds}s)..."

  local all_ids
  all_ids="$(fetch_channel_video_ids "$channel_url" "$min_seconds")"

  if [[ -z "$all_ids" ]]; then
    log "No videos found."
    return 0
  fi

  local total_count
  total_count="$(printf '%s\n' "$all_ids" | wc -l | tr -d ' ')"

  # Get channel name from first video
  local first_id
  first_id="$(head -1 <<< "$all_ids")"
  local channel_name
  channel_name="$(yt-dlp --print "%(channel)s" "https://www.youtube.com/watch?v=${first_id}" 2>/dev/null)"
  local ch_dir
  ch_dir="$(sanitize "$channel_name")"
  if [[ -z "$ch_dir" ]]; then
    ch_dir="unknown_channel"
  fi

  log "Channel: ${channel_name}"

  # Find already-transcribed video IDs
  local done_ids
  done_ids="$(get_transcribed_ids "${output_dir%/}/${ch_dir}")"

  # Build list of pending video IDs
  local num_pending=0
  while IFS= read -r vid; do
    if [[ -z "$done_ids" ]] || ! grep -qFx "$vid" <<< "$done_ids" 2>/dev/null; then
      pending_ids[$num_pending]="$vid"
      num_pending=$(( num_pending + 1 ))
    fi
  done <<< "$all_ids"

  local done_count=$(( total_count - num_pending ))
  log "Found ${total_count} videos, ${done_count} already transcribed, ${num_pending} remaining"

  if [[ $num_pending -eq 0 ]]; then
    log "Nothing to transcribe."
    return 0
  fi

  # Apply --amount limit
  local process_count=$num_pending
  if [[ "$amount" -gt 0 && $num_pending -gt "$amount" ]]; then
    process_count=$amount
  fi

  local amount_msg=""
  if [[ "$amount" -gt 0 ]]; then
    amount_msg=" (--amount=${amount})"
  fi
  log "Will transcribe ${process_count} videos${amount_msg} with ${workers} worker(s)"

  # Print the set of videos
  printf '\n  Videos to transcribe:\n'
  local i=0
  while [[ $i -lt $process_count ]]; do
    printf '    %d. https://www.youtube.com/watch?v=%s\n' "$(( i + 1 ))" "${pending_ids[$i]}"
    i=$(( i + 1 ))
  done
  printf '\n'

  # Build final list to pass to runners
  local to_process=()
  i=0
  while [[ $i -lt $process_count ]]; do
    to_process[$i]="${pending_ids[$i]}"
    i=$(( i + 1 ))
  done

  # Dispatch
  if [[ "$workers" -le 1 ]]; then
    run_sequential "$process_count" "${to_process[@]}"
  else
    run_worker_pool "$workers" "$process_count" "${to_process[@]}"
  fi
}

# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------
if [[ -n "$channel_url" ]]; then
  channel_mode
else
  transcribe_single_video \
    "$url" "$output_dir" "$model_path" "$no_gpu" "$language" \
    "$output_format" "$audio_format" "$keep_audio" "0" ""
fi
